// 1> 내가 외워서 작성: 시간초과 
// 백준 4963 섬의 개수 
#include <iostream>
#include <queue>
#include <stdio.h> 
#include <utility>
#include <cstring> //memset

using namespace std;
int w,h;
int sum{0};
int map[50][50];
int visited[50][50];
int dy[8]={-1,-1,0,1,1,1,0,-1}; int dx[8]={0,1,1,1,0,-1,-1,-1}; 

void bfs(int y,int x,int s){
  queue<pair<int, int>> q; 
  q.push({y,x});
  visited[y][x]=1;
  while(!q.empty()){
      y= q.front().first; x= q.front().second;
      q.pop();
      for(int d=0;d<8;d++){
          int ny= y+dy[d]; int nx=x+dx[d];
          if(ny>=h|| ny<0||nx>=w|| nx<0) continue; //0부터 시작해서 같아도 안된다. 
          if(map[ny][nx]==1&& visited[ny][nx]==0){
              q.push({ny,nx});
              visited[ny][nx]==1;
      }
      }
      
      
  }
    
}

int main()
{
    //cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false);
   while(1){
       scanf("%d %d", &w, &h);
       if(w==0&&h==0) break;
       memset(map,0,sizeof(map)); //!제발 다 쓰고 초기화해라. 
       memset(visited,0,sizeof(visited));
       sum=0;
       
       for(int y=0;y<h;y++){
           for(int x=0;x<w;x++){
             scanf("%1d", &map[y][x]);
           }
       }
       
       for(int y=0;y<h;y++){
           for(int x=0;x<w;x++){
              if(map[y][x]==1&&visited[y][x]==0){
                  bfs(y,x,sum++);
              }}}
       
   }
   
  printf("%d\n", sum);
   
    return 0;
}




//2> 내가 정답보면서 그대로 배낌: ㅋㅋ어이없어 시간초과 같은데 뭐가 달라 
// 백준 4963 섬의 개수 
#include <iostream>
#include <queue>
#include <stdio.h>
#include <cstring> //memset

using namespace std;
int w,h;
int sum{0};
int map[50][50];
bool visited[50][50];

int dy[8]={0, 1, 0 , -1, -1, 1,-1, 1}; int dx[8]={ 1, 0, -1, 0 , 1 , 1,-1,-1 }; 

void bfs(int y,int x){
  queue<pair<int, int>> q; 
   q.push(make_pair(y, x));
  visited[y][x]=true;
  while(!q.empty()){
      y= q.front().first; x= q.front().second;
      q.pop();
      for(int d=0;d<8;d++){
          int ny= y+dy[d]; int nx=x+dx[d];
          if (0 <= ny && 0 <= nx && ny < 25 && nx < 25){
                // 섬이면서 방문하지 않았다면
                if(map[ny][nx]&& !visited[ny][nx]){
              q.push(make_pair(ny, nx));
              visited[ny][nx]==true;
      } } } } }

int main()
{
    //cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false);
   while(1){
       scanf("%d %d", &w, &h);
       if(!w && !h) break;
       
       for(int y=0;y<h;y++){
           for(int x=0;x<w;x++){
             scanf("%1d", &map[y][x]);
           }
       }
       
       for(int y=0;y<h;y++){
           for(int x=0;x<w;x++){
              if(map[y][x] && !visited[y][x]){
                  bfs(y,x);
                  sum++;
              }}}
              
       printf("%d\n", sum);
       
        memset(map,false,sizeof(map)); //!제발 다 쓰고 초기화해라. 
       memset(visited,false,sizeof(visited));
       sum=0;
   }
   
   
    return 0;
}






//3> 이건 정답 아니 진짜 변수명만 다른데 뭐가 다르다는건지;;

#include <iostream>
#include <queue> // use bfs algorithm
#include <stdio.h> // use printf, scanf
#include <cstring> // use memset
 
#define MAX_SIZE 50
 
using namespace std;
 
int w, h;
int NumberOfLand = 0;
int graph[MAX_SIZE][MAX_SIZE];
bool visited[MAX_SIZE][MAX_SIZE];
 
// 우,하,좌,상,우상,우하,좌상,좌하
int dw[8] = { 1, 0, -1, 0 , 1 , 1,-1,-1 };
int dh[8] = { 0, 1, 0 , -1, -1, 1,-1, 1 };
 
void bfs(int h, int w) {
    queue< pair<int, int> > q; // 이용할 큐, (h,w)
    q.push(make_pair(h, w));
    
    // 처음 h,w를 방문 했기 때문에
    visited[h][w] = true;
    while (!q.empty()) {
        // 큐의 현재 원소를 꺼내기
        h = q.front().first;
        w = q.front().second;
        q.pop();
 
        // 해당 위치의 주변을 확인
        for (int i = 0; i < 8; i++) {
            int nh = h + dh[i];
            int nw = w + dw[i];
 
            // 지도를 벗어나지 않고,
            if (0 <= nw && 0 <= nh && nw < MAX_SIZE && nh < MAX_SIZE) {
                // 섬이면서 방문하지 않았다면
                if (graph[nh][nw] && !visited[nh][nw]) {
                    visited[nh][nw] = true;
                    q.push(make_pair(nh, nw));
                }
            }
        }
    }
}
 
void dfs(int h, int w) {
    // 처음 h,w를 방문 했기 때문에
    visited[h][w] = true;
 
    // 해당 위치의 주변을 확인
    for (int i = 0; i < 8; i++) {
        int nh = h + dh[i];
        int nw = w + dw[i];
 
        // 지도를 벗어나지 않고,
        if (0 <= nw && 0 <= nh && nw < MAX_SIZE && nh < MAX_SIZE) {
            // 섬이면서 방문하지 않았다면
            if (graph[nh][nw] && !visited[nh][nw]) {
                visited[nh][nw] = true;
                dfs(nh, nw);
            }
        }
    }
}
 
int main() {
    while (1) {
        scanf("%d %d", &w, &h);
        /* w=0 이면서 h=0이면 종료 */
        if (!w && !h) break;
 
        /* 그래프 정보 입력 */
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                scanf("%1d", &graph[i][j]);
            }
        }
 
        /* 그래프를 BFS 또는 DFS를 통해 탐색 */
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                // 땅이 존재하고(1), 방문하지 않았을 때(0)
                if (graph[i][j] && !visited[i][j]) {
                    NumberOfLand++;
                    bfs(i,j);
                    //dfs(i, j);
                }
            }
        }
 
        /* 섬의 개수를 출력 */
        printf("%d\n", NumberOfLand);
 
        /* 그래프 및 방문기록, 섬의 개수 초기화 */
        memset(graph, false, sizeof(graph));
        memset(visited, false, sizeof(visited));
        NumberOfLand = 0;
    }
    return 0;
}

