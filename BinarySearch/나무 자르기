//백준 2805 나무 자르기
// 최소한 m 은 가져가는데 최대 높이를 해서 환경보호 원한다. 
#include <iostream> 
#include <vector> 
#include <algorithm> 
using namespace std; 
int n,m; vector<int> v; 
int main() {
    cin >> n >> m; 
    for(auto i =0; i<n;i++) {
        int x; cin >> x; v.push_back(x); }
        int start =0; 
        int end= *max_element(v.begin(),v.end());
        int result=0; 
        while(start<=end) {
            long long int total = 0; 
            int mid = (start+end) / 2; 
            //BinerySearch는 항상 여기까지는 똑같다. 
            for(auto i =0; i<n;i++) {
                if (v[i]>mid) 
                total += v[i] - mid; }
                // 조건이 충족이 안되면 높이는 낮아지면서 환경보호를 덜 한다.
                // 앞부분 탐색 
                if(total<m) { end = mid -1; }
                // 조건이 충족되면 높이는 높아지면서 환경보홀 더 할 수 있다.
                // 뒷부분 탐색 
                else { result = mid; start = mid +1; } } 
    cout << result; }
