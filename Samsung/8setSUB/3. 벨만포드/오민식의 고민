// 1219 오민식의 고민 : 벨만포드
#include <cstdio>
#include <vector>
#include <queue>
#define INF 987654321
using namespace std;

int n, m,start_node,finish_node;
vector<pair<int, int>> adj[101]; //입력
vector<long long> ans(51,-INF); // 출력: 돈(+), 거리(비용-)
int money[101]; bool b;

// MST 프림함수와 매우 유사 (TV에 나올때 큐는 pop! top or front! 기준
bool bfs(int s, int e) { //사이클의 유무
    bool visited[101] = { 0 };
    queue<int> q; q.push(s);
    while(!q.empty()){
        int cur= q.front(); q.pop();
        if(visited[cur]) continue;
        visited[cur]=1; if(cur==e) return 1;
        for(auto next: adj[cur]){
            if(visited[next.first]) continue;
            q.push(next.first);}}
    return 0;}

bool bellman(int s, int isCycle) { //익숙한 벨만에 (매개변수가 생김)
    ans[s]=money[s];
    for(int r=0;r<n-1+isCycle; r++){
        for(int cur=0;cur<n;cur++){
            for(auto next: adj[cur]){
                if(ans[cur]==-INF) continue;
                if(ans[next.first]<ans[cur]+ next.second+money[next.first]){
                    ans[next.first]=ans[cur]+ next.second+money[next.first];
                    if(r==n-1){
                        if(bfs(next.first,finish_node)) return 1;}}}}}
    return 0;} //이부분

int main() {
    scanf("%d %d %d %d", &n, &start_node, &finish_node, &m);
    int a,b,c; for (int i = 0; i < m; i++) { //길에 대한 마이너스 비용
        scanf("%d %d %d", &a, &b, &c);
        adj[a].push_back({b, -c});}
    
    for (int i = 0; i < n; i++) { //노드당 벌 수 있는 돈
        scanf("%d", &money[i]);}
    
    //무한궤도는 둘다 1,1 이면 무한궤도가 된다
    bool infinite_cycle = bellman(start_node, 1);
    if(infinite_cycle) printf("Gee\n");
    // 길이 없는 경우
    else if (ans[finish_node] == -INF) printf("gg\n");
    // 갈 수 있고 cycle 없어서 값 나오는 경우
    else printf("%lld\n", ans[finish_node]); return 0;}
