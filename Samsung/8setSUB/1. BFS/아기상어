// BFS>QUEUE> 16236 아기상어
// 청소년상어 DFS와 연동하면 개쩌는건데..
/*! 친구들은 거치겠지만 천재들만 만나고싶을 때
q방에 친구들 넣기>  여기서 천재들 pq방에 넣기>
pq방에서 아이큐 순으로 정렬> 최고천재를 다시 q방에 넣기> 무한반복
pq방이 빌때 까지.*/

#include <iostream>
#include <queue>
using namespace std;

int n; int map[20][20]; // bool visited[20][20]={0,}; //여기에 놓으면 틀리네...wow
int dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};

struct Fish{
    int y,x,time;
    bool operator<(const Fish f)const{
        if(f.time==time){
            if(f.y==y) return f.x<x;
            return f.y<y;}
        return f.time<time;}};

queue<Fish> q; // 간다 Pq에는 먹는다

int bfs(){
    int res_time = 0, eat = 0, size = 2;
    //priority_queue<Fish> pq; // 메모리 초과
    
    while (1){ // q 안에 pq를 넣으려고 만들었다
        priority_queue<Fish> pq;
        
        bool visited[20][20]={0,};
        // q이동하는 조건 안에 먹을때 안에 pq를 만든다
        while (!q.empty()){
            Fish cur= q.front(); q.pop();
            for(int d=0;d<4;d++){
                int ny = cur.y+ dy[d]; int nx= cur.x+dx[d];
                if(ny>=n||nx>=n||ny<0||nx<0) continue;
                if(visited[ny][nx]|| map[ny][nx]>size) continue;
                visited[ny][nx]=1;
                q.push({ny,nx,cur.time+1}); // 필터망
                if(map[ny][nx]<size && map[ny][nx]!=0){
                    pq.push({ny,nx,cur.time+1});
                }
            }
        }
        
        if(pq.empty()) break;
        
       
        // 먹이 먹기= 조건에 맞는 순서에 따라 먹어야 하며 물고기 숫자가 0이 된다는 것을 의미
        int feedY = pq.top().y; int feedX = pq.top().x; eat++;
        if (eat == size){ size++; eat = 0; }
        
        // 먹이 위치로 이동
        map[feedY][feedX] = 0;
        q.push({feedY, feedX, 0});
        res_time += pq.top().time;} //while(1) 마무리

    return res_time;}




int main(){
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++){
            cin >> map[i][j];
            if (map[i][j] == 9){ map[i][j] = 0; q.push({i, j, 0});}}
    cout << bfs() << '\n';
    return 0;}
