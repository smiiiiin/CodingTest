// BFS>QUEUE> 16236 아기상어
// 청소년상어 DFS와 연동하면 개쩌는건데..
/*! 친구들은 거치겠지만 천재들만 만나고싶을 때
q방에 친구들 넣기>  여기서 천재들 pq방에 넣기>
pq방에서 아이큐 순으로 정렬> 최고천재를 다시 q방에 넣기> 무한반복
pq방이 빌때 까지.*/

#include <iostream>
#include <queue>
using namespace std;

int n; int dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};
int dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};
int map[20][20];  // bool  visited[20][20]; //주의하기

struct FISH{
    int y,x,time;
    bool operator<(const FISH f)const{
        if(f.time==time){
            if(f.y==y) return f.x<x;
            return f.y<y;}
        return f.time<time;}};

queue<FISH> q;

int bfs(){
    int res=0, eat=0,size=2;
    
    while (1){ // q 안에 pq를 넣으려고 만들었다
            priority_queue<FISH> pq;
            
            bool visited[20][20]={0,};
            // q이동하는 조건 안에 먹을때 안에 pq를 만든다
            while (!q.empty()){
                FISH cur= q.front(); q.pop();
                for(int d=0;d<4;d++){
                    int ny = cur.y+ dy[d]; int nx= cur.x+dx[d];
                    if(ny>=n||nx>=n||ny<0||nx<0) continue;
                    if(visited[ny][nx]|| map[ny][nx]>size) continue;
                    visited[ny][nx]=1;
                    q.push({ny,nx,cur.time+1}); // 필터망
                    if(map[ny][nx]<size && map[ny][nx]!=0){
                        pq.push({ny,nx,cur.time+1});}}}
        
        if(pq.empty()) break;
        
        FISH eatten= pq.top(); // pq.pop(); //pop을 하면 왜 안될까?
        eat++; if(eat== size){ size++; eat=0;}
        
        map[eatten.y][eatten.x]=0;
        q.push({eatten.y,eatten.x,0});
        //왜 다시 먹힌얘한테 넣을땐 0으로 넣지? //먹을때는 이동하는게 아니니깐, 시간이 안쓰니까
        res+= pq.top().time;} return res;}       

int main(){
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin>>n;
    for(int y=0;y<n;y++){
        for(int x=0;x<n;x++){
            cin>>map[y][x]; if(map[y][x]==9){
                map[y][x]=0; //내가 사라져야한다
                q.push({y,x,0});} } }
                
    cout<<bfs()<<"\n";
    return 0;}
