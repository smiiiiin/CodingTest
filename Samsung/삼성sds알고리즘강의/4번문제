// SAMSUNG SDS ALGORITHM특강 TEST4: 지하철환승
/*
 cin>> t 테케 개수
 cin>> n지하철 역개수는 10000이하, m 노선 수, 출발 s ,도착 e
 
 <input case>
 2
 18 5 2 17
 7 4 5 4 4
 2 3 4 7 10 9 8
 1 3 6 9
 5 6 7 13 14
 12 13 15 16
 11 16 17 18
 5 3 1 5
 3 2 3
 1 2 3
 2 4
 5 4 3
 
 <output>
 #1 3
 #2 1
 */

#include <iostream>
#include <vector>
#include <queue>
#include <cstring> //memset , 원래 fill알고리즘은 vector인데 []정적벡터는 memset을 쓴다
using namespace std;

int t, n, m, s, e; int hosun_num[20002]; vector<int> map[20002]; int ans[20001];

int bfs(){
    queue <int> q; ans[s] = 0; q.push(s);
    while(!q.empty()){
        int x = q.front(); q.pop();
        
        if(x == e) return ans[x] - 1 > 0 ? ans[x] - 1 : 0;
        
        for(auto next : map[x]) {
            if(ans[next] > -1) continue;
            if(next > 10000) ans[next] = ans[x] + 1;
            else ans[next] = ans[x];
            q.push(next);}
    }
    return -1;}

int main(){
    cin>>t; int k=1;
    while(t--){
    memset(ans,-1,sizeof(ans)); memset(hosun_num,0,sizeof(hosun_num)); memset(map,0,sizeof(map));
        
    cin >> n >> m>>s>>e;
    for(int i=1;i<=m;i++) cin>>hosun_num[i];
    for(int i = 1; i <= m; i++){
        int nn=hosun_num[i];
        while(nn--){
            int v; cin >> v;
            map[v].push_back(i+10000);
            map[i+10000].push_back(v); }}
        cout <<"#"<<k<<" "<<bfs()<<"\n"; k++;}}
 
