/* 

마당 잔디 깎기
시간제한: 최대404040개 케이스 합쳐 C/C++ 111초, Java 1.51.51.5초 / 메모리제한: 256MB256\text{MB}256MB(Stack 1MB1\text{MB}1MB)

그렉의 집 앞에는 마당이 있다. 마당의 크기는 세로 NNN 미터, 가로 MMM 미터이며, 마당에는 예쁜 잔디들이 자라나 있다. 
잔디들의 구역은 111 제곱미터 넓이로 구분되며, 잔디들은 성장이 빨라서 매일 아침 1cm1\text{cm}1cm 씩 자란다. 
그래서 그렉은 D 일동안 매일 K만큼의 기름을 구매해서 잔디를 깎으려 한다. (1≤i≤D1 \le i \le D1≤i≤D)
그렉은 예초기를 활용하여 잔디를 깎으며, 기름 111 당 잔디를 111제곱미터만큼 깎을 수 있다. 그렉은 잔디를 많이 깎는 것이 목적이다. 
그래서 매일 잔디를 깎을 때, 잔디의 높이가 가장 높은 구역을 깎기로 하였다. 또한 잔디를 모두 제거하면 안되기 때문에, 
잔디는 1cm를 남겨두고 모두 깎기로 했다. 가끔 가장 높은 곳이 여러 곳이지만 기름이 모자라는 경우가 있을 수 있는데, 그런 경우에는 아무 곳이나 깎기로 했다.


i일차에 깎는 길이가 Ai라 할 때, 
1×a1+2×a2+⋯+(D−1)×(aD−1)+D×aD1 를 구하여라.



위 그림은 세로 4, 가로 5 미터인 마당의 예시이다. 이 마당에서 4 일 동안 잔디를 깎으며 각각 날마다 3 2 2 4의 기름을 구매한다고 하자.
날마다 그렉이 깎은 잔디의 길이는 각각 총 114 61 40 67이다 
문제의 답은 1×114+2×61+3×40+4×67 이므로 624가 된다.
[주의] 주어진 식의 계산과정에서 int 범위를 넘어설 수 있음에 유의하시오.

[제한조건]
세로 N과 가로 M은 3 이상 300이하의 정수이다.
그렉이 구매하는 기름의 양은 1 이상 min⁡(400,N×M)이하의 정수이다.
그렉이 잔디를 깎을 일 수 D는 3 이상 20,000 이하의 정수이다.
초기 잔디의 높이는 1 이상 100이하의 정수이다.
[입력]
맨 처음 테스트 케이스의 개수 T
각 테스트 케이스의 첫 번째 줄에는 마당의 세로 크기 N, 마당의 가로 크기 M, 그렉이 잔디를 깎는 일 수 D 가 주어지며, 
두 번째 줄부터 마당의 잔디들의 길이가 공백으로 구분되어 주어진다. 
다음줄에는 D 일 동안 구매하는 기름의 양이 1 일째부터 순서대로 공백으로 구분되어 주어진다.

[출력]
테스트 케이스 하나 당 한 줄씩 출력한다. 맨 처음 #x (x는 테스트케이스 번호, 1부터 시작)을 출력하고 주어진 문제의 답을 출력하라.

[입출력 예]

(입력)
2
4 5 4
8 4 2 3 5
11 17 24 38 19
2 3 41 6 9
11 35 16 17 35
3 2 2 4
3 3 3
4 91 57
95 8 4
34 75 47
8 9 9


(출력)
#1 624
#2 464


(sample_input.txt 에 대한 출력)
#1 624
#2 464
#3 536
#4 674
#5 7779
#6 10842
#7 20538
#8 15444
#9 10554
#10 165486
#11 8705493
#12 10577887
#13 12106133748
#14 31629829192
#15 249880925573
#16 441131075065
#17 378093968526
#18 6455950934432
#19 16887577894318
#20 18005725885041
*/


//SAMSUNG SDS ALGORITHM특강 TEST

#include <iostream>
#include <algorithm> // sort, fill
#include <cstdio> // scanf("%d",변수)
#include <vector>
using namespace std;

int t; vector<int> map; vector<int> oil; vector<int> answer;

int main() {
    cin>>t;
    while(t--){
    cin>>n>>m>>d;
    for(int i=0;i<n*m;i++) cin>>map[i];
    for(int i=0;i<d;i++) cin>>oil[i];
    sort(map.begin(),map.end(),greater<>()); // 잔디 긴 순으로 나열
    // 날마다 주어진 kill칸 갯수를 돌아가며
    // map 의 앞부분부터 kill개수만큼 1로 바꾸고 map[i]-1을 답벡터에 저장
    for(int day=0;day<d;day++){
        int kill= oil[day];}
        for(int i=0;i<kill;i++){ answer[day].push_back(map[i]-1); map[i]=1; }
        for(int i=0;i<n*m;i++) map[i]++;
    }
    
    //답 출력하기
    
    
    // testcase돌릴때마다 map, oil, answer 초기화
    fill(map.begin(), map.end(),0);
    fill(oil.begin(), oil.end(),0);
    fill(answer.begin(), answer.end(),0);
    
    return 0;}
/*
 문제 파악>
 매일 1cm씩 자란다
 날마다 가장 큰걸 K개씩 1로 변경
 깎은 잔디의 cm를 저장하고 날짜를 곱한다
 1* (1일차에 깎은 cm)+ 2*(2일차에 깎은 cm)+ ...
*/

