// SAMSUNG SDS ALGORITHM특강 TEST5: 개미탈출

#include <iostream>
#include <string>
#include <cstring> // memset
#include <vector>
#include <algorithm>
#include <queue>
#include <stdio.h>
#define MAX 0071000000007

using namespace std;

/*
 cin>>n>>m>>
 k번 이하로 움직이다
 
 cout<< 탈출할 수 있는 방법의 가짓수
 
 */
int t,y,x,k; //k번 이내로
char map[101][101];

int bfs(){
    queue <int> q; ans[s] = 0; q.push(s);
    while(!q.empty()){
        //x는 역으로 시작했지만 호선이 될수도 역이 될수도 있다
        int x = q.front(); q.pop();
        
        if(x == e) return ans[x] - 1 > 0 ? ans[x] - 1 : 0;
        for(auto next : map[x]) {
            if(ans[next] > -1) continue;
            
            // 다음게 호선이면 현재 오기까지 환승횟수에서 +1
            if(next > 10000) ans[next] = ans[x] + 1;
            
            // 다음게 역이면 환승횟수유지
            else ans[next] = ans[x];
            
            //다음게 호선이던 역이던 그 수를 q로 넣는다
            q.push(next);
        }
    }
    return -1;
}

int main(){
    cin>>t;
    while(t--){
    memset(ans,-1,sizeof(ans));
    fill(hosun_num.begin(),hosun_num.end(),0);
    memset(map,0,sizeof(map));
    scanf("%d %d %d %d",&node,&n,&s,&e);
    //cin >> node >> n>> s >>e;
    
    //호선마다 역개수 입력받기
    for(int i = 0; i < n; i++) {
        int a; cin>>a;
        hosun_num.push_back(a);}
    for(auto i: hosun_num){
        while(i--){
            int v;
            scanf("%d",&v);
            cin >> v;
            map[v].push_back(i+10000);
            map[i+10000].push_back(v);
        }
    }
        printf("#%d %d",t,bfs()) ;
        //cout <<"#"<<t<<" "<<bfs();}
    }}
