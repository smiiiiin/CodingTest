// 2021 최소환승경로
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
int n, m, s, e;
vector<int> adj[200001];
int ans[200001];

int bfs(){
    queue <int> q; ans[s]=0;
    q.push(s); //시작 노드를 넣는다
    while(!q.empty()){
        int cur=q.front(); q.pop();
        if(cur==e) return ans[cur]; //노드가 도착노드면 지금까지의 환승횟수를 반환한다
        
        for(auto next: adj[cur]){ // cur이 호선이면 노드, cur이 노드면 호선
           //내 노드가 속한 호선별로 돌아보는데
            
            for(auto a: adj[next]){ //a= 1 3 6 9
                //방문 했으면,넘기고
                // 호선이 같건 다르건 다음 노드를 큐에 넣지만 호선이 다르면 환승횟수++;
                if(adj[cur]!=adj[a]) ans[a]++;
                q.push(a);}}}
    /*
    if(x == e) return ans[x] - 1 > 0 ? ans[x] - 1 : 0;
    
    for(auto next : map[x]) {
        if(ans[next] > -1) continue;
        if(next > 10000) ans[next] = ans[x] + 1;
        else ans[next] = ans[x];
        q.push(next);}
}
*/

    return -1;}

int main(){
    memset(ans,-1,sizeof(ans));
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        while(1){
            int v;
            cin >> v;
            if(v == -1) break;
            adj[v].push_back(i+100000);
            adj[i+100000].push_back(v);
        }
    }
    
    cin >> s >> e;
    cout << bfs();
}



/*
    호선번호랑 노드가 번갈아가면서 q에 들어가는게 28-32번코드가 이해가 안감. 손으로 일일히 해봐야하는데 일단 넘긴다 전체적인 큰틀과 필요한 변수를 
    잡고 와야겠다.
*/

