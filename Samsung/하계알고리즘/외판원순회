// 2098 외판원 순회 : 비트마스킹 + DP
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int INF = 987654321;
int n, weight[16][16];
/* dp[cur][visited] : [cur][cur노드까지 방문한 노드] 까지 가중치의 최소값
 3,4,2 방문한 visited 비트마스킹의 수가 있고 현재노드는 4
 여기까지의 가중치의 최소값 = dp[4][14]
 <14인 이유>
 idx 4 3 2 1 0  **참고로 node번호= idx번호+1; idx는 0부터 시작하니깐
       1 1 1 0 이므로 숫자는 14
*/
int dp[16][1<<16]; // ?

int TSP(int cur, int visited){
    int &ret = dp[cur][visited];
    if(ret != -1) return ret;
    // 모든 마을 방문했는가
    if(visited == (1<<n)-1){
        // current -> 0 이동 가능한지
        if(weight[cur][0] != 0) return weight[cur][0];
        
        return INF;}
    
    ret = INF;
    for (int i = 0; i < n; ++i){
        // 방문했거나 || current -> i 로 길이 없거나
        if(visited & (1<<i) || weight[cur][i] == 0) continue;
        ret = min(ret, TSP(i, visited|(1<<i)) + weight[cur][i]);}
   
    return ret;}

int main (){
    ios_base::sync_with_stdio(false);cout.tie(NULL);cin.tie(NULL);
    cin >> n;
    for (int i = 0; i < n; ++i){
        for (int j = 0; j < n; ++j)
            cin >> weight[i][j];}
    memset(dp,-1,sizeof(dp));
    cout << TSP(0,1) << '\n';
return 0;}
