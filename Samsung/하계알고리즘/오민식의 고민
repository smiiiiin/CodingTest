// 1219 오민식의 고민 : 플로이드 워셜
/*
 비용이 양의 무한대가 되면 infinite_cycle이 발생하면서 계산을 못해
 도시- 이동비용 도시돈은 최대로 이동비용은 최소로 만들어야하니까
 이동비용에 -를 붙여서 최대값으로 갱신하되, 계속 갱신되면 문제있는 걸로 치부

 반대도 괜찮은데... 도시돈에 -를 붙여서 최소값으로 갱신하되, 계속 갱신되면 -(이하동문)
 버는돈(money) -쓰는돈(ans) 을 최대로 
 
 */
#include <cstdio>
#include <vector>
#include <queue>
#define INF 987654321
using namespace std;

int n, m,start,finish, f,t, co;
vector<pair<int, int>> adj[101]; //입력
int money[101]; long long ans[101]; // 출력: 돈(+), 거리(비용-)

int bfs(int S, int E) {
    if (S == E) return 1;
    int visited[101] = { 0 };
    queue<int> q;
    q.push(S);
    visited[S] = 1;
    while (!q.empty()) {
        int cur = q.front(); q.pop();
        for (auto next: adj[cur]) {
            int nn = next.second;
            if (visited[nn]) continue;
            visited[nn] = 1;
            if (nn == E) return 1;
            q.push(nn);}}
    return 0;}

// 사이클이 여러개 있을 수도 있어서 사이클마다 E로 갈 수 있는지 체크
// 갈 수 있으면 그 node 번호 return
// 갈 수 없으면 -1 return
int bellman(int S, int isCycle) {
    ans[S] = money[S];
    for (int j = 0; j < n-1 + isCycle; j++) {
        for (int cur = 0; cur < n; cur++) {
            if (ans[cur] == -INF) continue;
            
            for (auto next: adj[cur]) {
                int nc = next.first; int nn = next.second;
                
                if (ans[nn] < ans[cur] + nc + money[nn]) {
                    ans[nn] = ans[cur] + nc + money[nn];
                    if (j == n - 1) { //음의 사이클이 있다는거다
                        if (bfs(nn, finish)) return nn;
                    }}
            }}}
    return -1;}



int main() {
    scanf("%d %d %d %d", &n, &start, &finish, &m);
    adj->clear(); //2차원배열 clear하는 법
    
    for (int i = 0; i < m; i++) {
        scanf("%d %d %d", &f, &t, &co);
        adj[f].push_back({ -co,t });
    }
    for (int i = 0; i < n; i++) {
        scanf("%d", &money[i]);
    }

    fill_n(ans, sizeof(ans) / sizeof(long long), -INF);
    //무한대로 늘 수 있는지 사이클 확인
    int infinite_cycle = bellman(start, 1);
    // 갈 수 없으면 gg
    if (ans[finish] == -INF) {
        printf("gg\n");
    }//갈 수 있는데 cycle 존재하는 경우
    else if (infinite_cycle!=-1) {
        printf("Gee\n");
    }//갈 수 있고 cycle 없는 경우
    else {
        printf("%lld\n", ans[finish]);
    }

    return 0;
}
