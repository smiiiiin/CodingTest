// 1197 최소 스패닝 트리
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

struct NODE{
    int to_node, cost;
    NODE(int a, int b){to_node=a; cost=b;}
    bool operator< (const NODE n)const {return n.cost<cost;}
};
long long ans{0}; //int ans[MAX] 대신에 prim은 답이 하나고, 무방향이다
bool visited[10001];
vector<NODE> adj[10001];

long long prim() {
    priority_queue<NODE>pq; // first는 가중치 second 는 정점 minheap
    pq.push(NODE(1,0)); //1번 정점부터 시작       // 가중치가 가장작은것이 top으로 가게된다!
    
    while(!pq.empty()) {
        int cn= pq.top().to_node;int cc= pq.top().cost; pq.pop();
        
        if(visited[cn]) continue;
        visited[cn] = 1; ans += cc;
        
        for (auto next: adj[cn]) { //현재 정점에서 이동 할 수 있는 방문하지 않은 정점 푸쉬
            if (!visited[next.to_node]) pq.push(next);}
    }
    
     return ans;}


int main(void) {
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    int n, m; cin >> n >> m;
    
    for(int i = 0; i < m; i++) {
        int a,b,c;
        cin >> a>>b>>c;
        adj[a].push_back(NODE(b,c));
        adj[b].push_back(NODE(a,c));}
    
    long long result = prim();
    cout<< result;
    return 0;
}
