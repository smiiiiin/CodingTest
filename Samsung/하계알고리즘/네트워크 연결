// 1922 네트워크 연결 : 트리- Prim 알고리즘
// cost낮은 순으로 정렬한 후, 해당되는 노드를 칠하고 이에 인접하는 노드를
// 칠해가는 과정
#include <cstdio>
#include <algorithm>
using namespace std;

struct NODE{ int from,to,cost;}; NODE v[100000]; //간선
int n,m; int parent[1000];
bool cmp(NODE N, NODE N1){ return N.cost< N1.cost;} //작은게 앞에 있는 오름차순

int find(int x){
    if(parent[x]==x) return x;
    return find(parent[x]);}

void join(int a,int b){
    int Agroup= find(a); int Bgroup= find(b);
    if(Agroup==Bgroup) return;
    parent[Bgroup]=Agroup;}

int main(){
    scanf("%d",&n);scanf("%d",&m);
    for(int i=0;i<m;i++){
        scanf("%d %d %d",&v[i].from,&v[i].to,&v[i].cost);}
    sort(v, v+m, cmp); // 노드가 가중치 오름차순으로 정렬된다
    
    // 초기화
    for(int i=1;i<=n;i++) parent[i]=i; int sum{0};
    
    //그럼 위에서부터 from-to노드를 join한다. 근데 join하려면 그 전에 find를 해야한다
    for(int i=0;i<m;i++){
        //선이 연결되어 있지 않으면 연결한다
        if(find(v[i].from)!=find(v[i].to)){
        join(v[i].from, v[i].to); sum+=v[i].cost;
        }}
    
        printf("%d\n",sum);
        return 0;}
