//백준 1922 네트워크 연결 : 트리(나무니깐 비순환, 연결그래프 ! 노드가 n일때 간선은 n-1
// 간선이 하나 더 있으면 cycle이 되고 하나 더 적으면 연결이 끊어진다 ) mst>프림 알고리즘
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int n, m; vector<pair<int,int>> edge[100001]; bool visited[100001];

// 비용중심으로 정렬을 시킨다 근데 greater는 오름차순인데... ??
// pq는 front()가 아니라 top()을 사용;
int prim() {
    // pq <자료형, 그릇<자료형>, 비교함수>
    priority_queue <pair<int, int>, vector<pair<int, int>>, greater<pair<int, int >>> pq;
    // {비용, 다음노드}
    int result=0;
    pq.push( { 0,1 }); // 초기값 비용은 0이고 노드는 1에서 시작한다
    
    for (int i = 1; i <= n; i++) {
        //비지 않는 동안, top()은 front()=cur같은 느낌. 다음노드를 방문했다면 pop();
        while (!pq.empty() &&visited[pq.top().second]) pq.pop();
        // 다음노드 pq에서 자동정렬되니까 아마 가중치가 큰 노드를 먼저 연결 할것임
        int next = pq.top().second;
        int minCost = pq.top().first;
        visited[next] = true;
        result += minCost;
        for (auto o : edge[next]) { //next에 연결된 노드를 하나씩 가져오면서
            pq.push({ o.second,o.first }); //그 노드들의 {비용,상대노드}pair를 넣는다
        }
    }
    return result;}

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n >> m;
    
    for (int i = 0; i < m; i++) {
        int from, to, cost;
        cin >> from >> to >> cost;
        edge[from].push_back({ to ,cost });
        edge[to].push_back({ from,cost });}

    cout << prim();         return 0;}
