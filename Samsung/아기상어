// 16236 아기상어 그점으로부터의 가중치를 계산해야하는데 그 점이 계속 움직이면
// struct안에 답을 넣어라
#include <iostream>
#include <queue>
#include <cmath>
#include <vector>
using namespace std;

int n; int map[20][20]; // bool visited[20][20]={0,}; //여기에 놓으면 틀리네...wow
int dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};

struct Fish{
    int y, x, time; //시간(답)이 곧 이동한 칸 개수
    bool operator<(const Fish &b) const{
        if (time == b.time){
            if (y == b.y)
                return b.x<x;
            return b.y<y;}
        return b.time<time;}};

queue<Fish> q; //좌표랑 거리(=시간) 답이랑 같이 저장

// !! 움직인다. 먹는다를 각각 나눈 것이다 q는 움직이는 것, pq는 먹는 것

int getMaxTime(){
    int res_time = 0, eat = 0, size = 2;
    //priority_queue<Fish> pq; //메모리 초과
    
    while (true){ //q는 q여서 이동하는거야 편안하게 생각해 근데
        //while(1)을 만들면서 pq를 안에 넣어주면서 우선순위 생각하면서 먹는 것 까지 고려한다
        //왜? 먹는데에 우선순위가 있으니까 말그대로-
        //while(1) 왜 하는거야? 다 먹을때까지 계속 먹을거니까
        priority_queue<Fish> pq;
        bool visited[20][20]={0,};
        // bfs로 먹을 수 있는 먹이 모두 찾기
        while (!q.empty()){
            Fish cur = q.front(); q.pop();

            for (int d = 0; d < 4; d++){
                int ny = cur.y + dy[d], nx = cur.x + dx[d];
                if (ny < 0 || nx < 0 || ny >= n || nx >= n) continue;
                //size는 언제 키우나
                if (visited[ny][nx] || map[ny][nx] > size) continue;
                visited[ny][nx] = 1;
                q.push({ny, nx, cur.time + 1});
                if (map[ny][nx] < size && map[ny][nx] != 0)
                    pq.push({ny, nx, cur.time + 1});
            }
        }
        
        // 다 먹었으면 break;
        if (pq.empty()) break;
        
       
        // 먹이 먹기= 조건에 맞는 순서에 따라 먹어야 하며 물고기 숫자가 0이 된다는 것을 의미
        int feedY = pq.top().y; int feedX = pq.top().x;
        if (++eat == size){ eat = 0; size++;}
        
        // 먹이 위치로 이동
        map[feedY][feedX] = 0;
        q.push({feedY, feedX, 0});
        res_time += pq.top().time;}

    return res_time;}




int main(){
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++){
            cin >> map[i][j];
            if (map[i][j] == 9){
                map[i][j] = 0; q.push({i, j, 0});}}
    cout << getMaxTime() << '\n';
    return 0;}
