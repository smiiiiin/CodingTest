#include <iostream>
#include <vector>
#include <cstdio>
#define MAX 1001
#include <algorithm>
int map[MAX][MAX];
bool visited[MAX][MAX];
int dy[4]={-1,1,0,0};
int dx[4]={0,0,-1,1};
using namespace std;

int main() {
    int a,b;
    cin>>a>>b;
    for(int y=0;y<b;y++){
        for(int x=0;x<a;x++){
            cin>>map[y][x];
        }
    }
    return 0;
}
//2 2
/* 지렁이(싹쓸이)기법을 쓸 공간이 안된다.
 1 0 더 큰거 선택
 0 1
 //!!행이나 열 중 하나라도 홀수가 있으면 싹쓸이 해야한다.
 방향 설정만 잘하면 된다.
 !! 근데 행도 열도 짝수면 하나만 포기해야한다 근데 개수를 적게 포기하는게
 핵심이 아닌게 걔가 1억짜리행복이면 걔만 먹어도 max다.
 -> 생각 변함. 해보니까 최소값 하나 빼고 싹쓸이 가능하다. 방향설정에만 신경쓰면 됨.
 경우의 수 4가지로
    행   열
 1) 짝   홀
 2) 홀   짝
 3) 짝   짝 !하나는 포기
 4) 홀   홀
 
 
 1 0 0
 0 1 1 밑으로 위아래로 가는지렁이 b가 2일때(a>=3)
 a(x,열)가 홀수면 아래부터 가서 싹쓸이 지렁이,
 
 a(x,열)가 짝수면
 1 2 3 4
 4 3 2 1 양대각선 끝 수 4 중 하나를 포기
 
 b(행,y)이 홀수면 (>1) 열에 관계없이, 오른쪽부터 가는 싹슬이 지렁이
 1 2
 1 2
 1 2
 
 행이 짝수면(>0) 열에 관계없이,
 1 억 3 억
 억 4 억 3   !!!!!2) 밑에 경우 반박 원하면 하나 포기하고 억7개 먹는 경로 찾아내라.
 0 3 2 억   증명1) 여러개 포기하고 억7개 먹을 수 있음? 이게 최선인데 이 경우에 하나만 포기하지x
 억 5 억 5  1개만 포기 가능 U자 그리고 2모양으로 하면 1개(억) 만 포기 가능: 의미없어짐.
 //근데 개수를 적게 포기하는게 의미가 없다. 걔가 최고치일 수도있으니
 1 2 3 4 5 6
 3 4 5 6 7 8
 1 2 3 4 5 6
 3 4 5 6 7 8
 1 2 3 4 5 6
 3 4 5 6 7 8
 1 2 3 4 5 6
 3 4 5 6 7 8
 1 2 3 4 5 6
 3 4 5 6 7 8
 
 
 
 
 
 
 
 
 
 */
