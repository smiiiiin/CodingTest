#include <iostream>
#include <vector>
#include <cstdio>
#define MAX 1001
#include <algorithm>
int map[MAX][MAX];
bool visited[MAX][MAX];
int dy[4]={-1,1,0,0};
int dx[4]={0,0,-1,1};
using namespace std;

int main() {
    int a,b;
    cin>>a>>b;
    for(int y=0;y<b;y++){
        for(int x=0;x<a;x++){
            cin>>map[y][x];
        }
    }
    return 0;
}
//2 2
/* 지렁이(싹쓸이)기법을 쓸 공간이 안된다.
 1 0 더 큰거 선택
 0 1
 //!!행이나 열 중 하나라도 홀수가 있으면 싹쓸이 해야한다.
 방향 설정만 잘하면 된다.
 !! 근데 행도 열도 짝수면 하나만 포기해야한다 근데 개수를 적게 포기하는게
 핵심이 아닌게 걔가 1억짜리행복이면 걔만 먹어도 max다.
 -> 생각 변함. 해보니까 최소값 하나 빼고 싹쓸이 가능하다. 방향설정에만 신경쓰면 됨.
 경우의 수 4가지로
    행   열
 1) 짝   홀
 2) 홀   짝
 3) 짝   짝 !하나는 포기
 4) 홀   홀
 
 
 1 0 0
 0 1 1 밑으로 위아래로 가는지렁이 b가 2일때(a>=3)
 a(x,열)가 홀수면 아래부터 가서 싹쓸이 지렁이,
 
 a(x,열)가 짝수면
 1 2 3 4
 4 3 2 1 양대각선 끝 수 4 중 하나를 포기
 
 b(행,y)이 홀수면 (>1) 열에 관계없이, 오른쪽부터 가는 싹슬이 지렁이
 1 2
 1 2
 1 2
 
 행이 짝수면(>0) 열에 관계없이,
 1 억 3 억
 억 4 억 3   !!!!!2) 밑에 경우 반박 원하면 하나 포기하고 억7개 먹는 경로 찾아내라.
 0 3 2 억   증명1) 여러개 포기하고 억7개 먹을 수 있음? 이게 최선인데 이 경우에 하나만 포기하지x
 억 5 억 5  1개만 포기 가능 U자 그리고 2모양으로 하면 1개(억) 만 포기 가능: 의미없어짐.
 //근데 개수를 적게 포기하는게 의미가 없다. 걔가 최고치일 수도있으니
 1 2 3 4 5 6
 3 4 5 6 7 8
 1 2 3 4 5 6
 3 4 5 6 7 8
 1 2 3 4 5 6
 3 4 5 6 7 8
 1 2 3 4 5 6
 3 4 5 6 7 8
 1 2 3 4 5 6
 3 4 5 6 7 8
 */
 
 //답+ 정리
 /* https://suhwanc.tistory.com/23 */
//백준 2873 rollercoaster
#include <iostream>
#include <string>
#include <vector>

#define INF 0x3f3f3f3f //infinite로 두는이유: memset편하고 overflow2배해도 안발생
using namespace std;

int x, y; //(행,렬)이 맞는데 좌표로하면 개념을 다르게 잡긴함 내가 y,x로 항상 했으니까.
int arr[1001][1001];
string ans;

int min_val = INF;
int min_i;
int min_j;

string Rep(char c, int n) {
    string ret = "";
    while (n--) ret += c; //뒤에다가 그냥 스트링 붙이는 거다. L뒤에 D뒤에 U...
    return ret;
}

void Solve(void) {
    if (x % 2) { //case2: 행이 홀수면
        for (int i = 0; i < x; i++) {
            if (i % 2 == 0) ans += Rep('R', y - 1); //행이 홀수 일때, 열 개수만큼 R
            else ans += Rep('L', y - 1);            //행이 짝수 일때, 열 개수만큼 L
            
            if (i != x - 1) ans += 'D'; //맨 마지막에만 안내려오고 앞에 if-else문 하고 필수로 똑
        }
    }
    else if (y % 2) { //case1: 열이 홀수면
        for (int j = 0; j < y; j++) {
            if (j % 2 == 0) ans += Rep('D', x - 1); //열이 홀수 일때, 여행 개수만큼 D
            else ans += Rep('U', x - 1); //열이 짝수 일때, 여행 개수만큼 U
            
            if (j != y - 1) ans += 'R'; //맨 마지막에만 안내려오고 앞에 if-else문 하고 필수로 똑
            
        }
    }
    else {// <집중> 짝x짝 case3: 최소값에서 흰색 하나만 빼는 경우
        bool vacancy = false;
        for (int i = 0; i < x; i += 2) { //검은판 단위
            
            if (min_i == i || min_i == i + 1) { //min_i=i면 안되는 거 아님? 진작 피했어야지
                bool up = false; //일단 아래로 내리고 시작해
                vacancy = true; //공백을 주위로
                for (int j = 0; j < y; j++) {
                    if (min_j != j) { //빈칸과 행은 같은데 열이 다를땐 위아래로 피하기
                        if (up) ans += 'U';
                        else ans += 'D';
                        up = !up; //up&down 스위치
                    }
                    if (j != y - 1) ans += 'R'; //열이 끝이 아니라면 계속 오른쪽
                }//(여기까지 위아래로 꾸불지렁이) 다 했는데
                if (i != x - 2) ans += 'D'; //행이 y좌표가 하나위라면 (밑에 칸있다면) 아래로
            }
            
            
            else { //??공백이 아니면 min_i와 관계없으면 ? 바로 vancancy면??
                if (vacancy) {//공백을 주위로
                    ans += Rep('L', y - 1);//열이 같으면 왼오로 피하고
                    ans += 'D';
                    ans += Rep('R', y - 1);
                }
                else {
                    ans += Rep('R', y - 1);
                    ans += 'D';
                    ans += Rep('L', y - 1);
                }
                if (i != x - 2) ans += 'D'; //Rep로 다 했는데도 아래 칸 있으면 밑으로 
            }
        }
    }

    cout << ans;
}

void Init(void) {
    cin >> x >> y;
    for (int i = 0; i < x; i++) {
        for (int j = 0; j < y; j++) {
            cin >> arr[i][j];
            if ((i+j)%2 && min_val > arr[i][j]) {
                //0부터 시작이고 흰색에서 삭제해야하니까, 짝-홀인 경우
                min_val = arr[i][j];
                min_i = i;
                min_j = j;
            }
        }
    }
}

int main() {
    cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(false);
    Init();
    Solve();
    cout<<"\n";
    return 0;
}
