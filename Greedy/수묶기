// 백준 1744 수묶기

// 내가 손코딩 한것.
// ! 시험에서는 변수의 위치의 오류를 잡아주지 않는다.
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
vector<int> v;
int res{0};
bool les(int a, int b){
    return a>b;
}

int pack(int f, int s){
    res+= f*s;
    return res;
}

int main() {
    //cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(false);
    bool zero{0};
    int n;
    int minus=0;
    int plus=0;
    scanf("%d", &n);
    int num;
    for(int i=0;i<n;i++){
        scanf("%d", &num);
        v.push_back(num);
    }
    sort(v.begin(), v.end(), les);//내림차순 정렬
    int sz= v.size();
    
    for(int i=0;i<sz;i++){
        
        if(v[i]==0){
          zero=1;
        }
        while(v[i]>0){
            plus++;
        }
        while(v[i]<0){
            minus++;
        }
    }
    
    if(!zero&& plus>0){ //0이 없다면, 양수만 있다면
        if(!sz%2){ //근데 그게 짝수개수면
            for(int i=0;i<sz;i+=2){
                pack(v[i],v[i+1]);
            }
        }
        else { //홀수 개수면
            for(int i=0;i<sz-1;i+=2){
                pack(v[i],v[i+1]);
            }
            res+=v[sz-1]; //마지막 하나는 그냥 더한다.
        }
        
    }
    
    if(minus>0 && !minus%2){//음수 개수가 짝수개면
        for(int i=sz-minus ;i<sz;i+=2){
            pack(v[i],v[i+1]);
        }
        
    }
    else if(minus>0 && minus%2){ //음수 개수가 홀수개면
        if(zero){ //근데 0이 있으면 가장 왼쪽 음수랑 곱하고 그냥 순서대로 곱하면 됨.
            for(int i=sz-minus ;i<sz;i+=2){
                pack(v[i],v[i+1]);
            }
        }
        else //0이 없으면
        {
            for(int i=sz-minus+1;i<sz-1;i+=2){
                pack(v[i],v[i+1]);
            }
            res+=v[sz-minus]; //마지막 하나는 그냥 더한다.
        }
                 
    }
    
    printf("%d \n",&res);
    
    
    return 0;
}
