//백준 10971 외판원 순회2 
//정답
#include <iostream>
#include <algorithm>
using namespace std;

int arr[11] = { 0 };
bool visited[11] = { 0 };
int map[11][11] = { {0} };

int n;
int res = 987654321;

void dfs(int depth, int sumCost) {

	if (sumCost > res) { // 시간 줄여줌
		return;
	}

	int cost;

	if (depth > n) {
		cost = map[arr[n]][arr[1]];
		if (cost == 0) return;

		res = min(sumCost + cost, res);
		return;
	}

	for (int i = 1; i <= n; i++) {
		if (visited[i]) continue;

		arr[depth] = i;
		cost = map[arr[depth - 1]][arr[depth]]; //depth는 2부터 시작
		if (cost == 0) {
			continue; // return으로 쓰면 안됨.
		}

		visited[i] = true;
		dfs(depth + 1, sumCost + cost); // sum값 누적
		visited[i] = false;
	}

}

int main() {
	cin.tie(NULL); cout.tie(NULL); ios::sync_with_stdio(false); cin >> n;

	for (int y = 1; y <= n; y++) {
		for (int x = 1; x <= n; x++) {
			cin >> map[y][x];
		}
	}

	for (int i = 1; i <= n; i++) { // depth 1 처리
		arr[1] = i;
		visited[i] = true;
		dfs(2, 0);
		visited[i] = false;
	}
	cout << res;
	return 0;
}

//내오답
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int n;
int map[11][11];
vector<int> v;
int visit[11]; //마지막에 처음방문한 곳 무조건 가줘야함. 
int result{987654321};

void solve() { //브루트포스 
	if (v.size() == n) {  
		int tmp{0}; 
		for (int i = 0; i < n-1; i++) {
		    if(map[v[i]][v[i+1]]==0) return; 
		    //여기서 return이 아니라, 아예 다른데 return으로 작용해야하는데.. 이거때문에 매개변수 1개로 
			tmp += map[v[i]][v[i+1]];
		}
		int last= v[n-1]; int first= v[0];
	    tmp+= map[last][first];
		result = min(result, tmp);
		return;
	}
	
	for (int i = 1; i <= n; i++) { //백트래킹
		if (!visit[i]) {
			visit[i] = 1;
			v.push_back(i);
			solve();
			v.pop_back();
			visit[i] = 0;
		}
	}
}

int main() {
	cin >> n;
	for(int y=1;y<=n;y++){
	    for(int x=1;x<=n;x++){
	        cin>>map[y][x];
	    }
	}

	solve();
	cout << result << endl;
}
