//백준 10971 외판원 순회2 


//내오답
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int n;
int map[11][11];
vector<int> v;
int visit[11]; //마지막에 처음방문한 곳 무조건 가줘야함. 
int result{987654321};

void solve() { //브루트포스 
	if (v.size() == n) {  
		int tmp{0}; 
		for (int i = 0; i < n-1; i++) {
		    if(map[v[i]][v[i+1]]==0) return; //여기서 return이 아니라, 아예 23번 줄 return으로 작용해야하는데..
			tmp += map[v[i]][v[i+1]];
		}
		int last= v[n-1]; int first= v[0];
	    tmp+= map[last][first];
		result = min(result, tmp);
		return;
	}
	
	for (int i = 1; i <= n; i++) { //백트래킹
		if (!visit[i]) {
			visit[i] = 1;
			v.push_back(i);
			solve();
			v.pop_back();
			visit[i] = 0;
		}
	}
}

int main() {
	cin >> n;
	for(int y=1;y<=n;y++){
	    for(int x=1;x<=n;x++){
	        cin>>map[y][x];
	    }
	}

	solve();
	cout << result << endl;
}
