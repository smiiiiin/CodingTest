//9019 DSLR
// next: 1525, 2251
#include<iostream>
#include <list>
#include<cstring>
#include<queue>
#include<string>
#define MAX 10000
using namespace std;
//방문해준 횟수는 있어야하고 내가 소개받을때 주인의 숫자와 연산을 기억한다.

char c[4] = {'D', 'S', 'L', 'R'};
pair<int, char> cal[10000]; //나를 소개해 준 친구와 그때 눌렀던 연산
int a, b;

void bfs(){
        queue<int> q;
        q.push(a);
        cal[a] = {-1, ' '};
        
        while(!q.empty() ){
            int cur = q.front(); q.pop();
            if(cur == b) break;
            for(int op = 0; op < 4; op++){
                int nx;
                if(op == 0){    // D 연산
                    nx = (2 * cur) % 10000;
                }else if(op == 1){  // S 연산
                    nx = (cur == 0) ? 9999 : cur - 1;
                }else if(op == 2){  // L 연산
                    nx = (cur % 1000) * 10 + (cur / 1000);
                }else{// R 연산
                    nx = (cur / 10) + (cur % 10) * 1000;
                }
//주인이 있다는 것 자체가 방문했다는 거다.
                if(cal[nx].first >= -1) continue; // 이미 방문한 경우, 방문하지 않음
                q.push(nx);
                cal[nx].first = cur; //자기 초대해 준 숫자를 저장한다.
                cal[nx].second= c[op];//나를 불러온 연산을 저장한다.
            }}}

int main(){
    //ios::sync_with_stdio(0);cin.tie(0);
    int t; scanf("%d",&t);
    while(t--){
        scanf("%d %d",&a,&b);
        fill(cal, cal + 10000, make_pair(-2, ' '));
        
        bfs();
        
        int cur = b;
        list<char> ops;
        while(cur!=a){
            ops.push_front(cal[cur].second);
            cur = cal[cur].first;
        }

        for(auto c : ops) printf("%c",c);
        printf("\n");}
}

