// 백준 9019 DSLR
// 1525, 2251
#include<iostream>
#include<cstring>
#include<queue>
#include<string>
#define MAX 10000
using namespace std;
bool prime[MAX]; bool Visit[MAX]; int Start, End;
 
void Initialize(){

    memset(prime, 1, sizeof(prime));
        for(int i=2;i< MAX;i++){
            for(int j=i;j*i<MAX;j++){
                prime[i*j]=0;
            }
        }
    
    memset(Visit, 0, sizeof(Visit));    
    }
int cnt{0};
void Solution(){
    queue<pair<int,int>> q;
    q.push({Start,0});
    Visit[Start]=1;
    
    while(!q.empty()){
        int cur= q.front().first; cnt= q.front().second; q.pop();
        if(cur==End ){
        cout<<cnt<<"\n"; return;}
        
        for(int i=0;i<4;i++){
            for(int j=0;j<10;j++){
                string s= to_string(cur);
                s[i] =j+'0';
                int next= stoi(s);
                
                if(!prime[next]|| Visit[next]|| next>9999 || next<1000) continue;
                q.push({next,cnt+1}); Visit[next]=1;
            }
        }
    }
    
cout<<"Impossible"<<"\n";
    
}
    

 
int main(void)
{
    ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
    int t; cin >> t;
    for (int T = 1; T <= t; T++){
        Initialize(); //test여러번 하기 위한 초기화 
        cin >> Start >> End;
        Solution();}
    return 0;
}

//지금 하는 중
// 백준 9019 DSLR
// 1525, 2251
#include <bits/stdc++.h>
using namespace std;

#define pre first
#define op second

char c[4] = {'D', 'S', 'L', 'R'};

int main(){
    ios::sync_with_stdio(0);cin.tie(0);
    int t; cin >> t;
    while(t--){
        int start, end;
        cin >> start >> end;
        //fill(vis, vis + 10000, make_pair(-2, ' ')); //(-2, ' ')로 초기화

        queue<pair<int,char>> q;
        q.push(start);
        
        while(!q.empty()){
            int cur = q.front().first; char recommend = q.front().second; q.pop();
            if(cur == end) return;
            
            for(int op = 0; op < 4; op++){
                int nx;
                if(op == 0){    // D 연산
                    nx = (2 * cur) % 10000;
                }else if(op == 1){  // S 연산
                    nx = (cur == 0) ? 9999 : cur - 1;
                }else if(op == 2){  // L, R 연산
                    nx = (cur % 1000) * 10 + (cur / 1000);
                }else{
                    nx = (cur / 10) + (cur % 10) * 1000;
                }

                if(vis[nx].pre >= -1) continue; // 이미 방문한 경우, 방문하지 않음
                q.push(nx);
                vis[nx].pre = cur;
                vis[nx].op = c[op];
            }

        }

        int cur = b;
        list<char> ops;
        while(true){
            if(cur == a) break;
            ops.push_front(vis[cur].op);
            cur = vis[cur].pre;
        }

        for(auto c : ops) cout << c;
        cout << "\n";
    }
}
